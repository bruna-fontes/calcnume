---
title: "Atv_4"
author: "Bruna e Nathalha"
date: "22/04/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Atividade 4 - Utilizar os modelos iterativos para encontrar os zeros em algum problema da área

O problema escolhido é fazer a modelagem de um circuito elétrico RLC (Resistor Indutor e Capacitor) através da função de transferência (FT), encontrar os polos da FT e então calcular a estabilidade. 

Será definido valores iniciais de R, L e C, porém serão alterados para poder analisarmos a influência na estabilidade do circuito.

O circuito utilizado será o seguinte:


![RLC](https://raw.githubusercontent.com/bruna-fontes/calcnume/main/RLC.png?token=GHSAT0AAAAAABTXKG7TX4HNE5FLA4XJLQL4YTCJXMQ)

Função de transferência


```{r}



FT<- function(s){
  denom<- R1C1*R2C2*(s^2) + (R1C1 + R2C2+ R1C2)*s +1
  ft = 1/denom
  return(denom)
}
```
(R1C1 + R2C2+ R1C2)^2 vai ser maior que R1C1*R2C2, então temos respostas reais. Precisamos encontrar os zeros do denominador da FT

```{r}
R1C1<- 0.4
R2C2 <-0.2
R1C2 <- 0.5


beta<-R1C1 + R2C2+ R1C2
delta<-(R1C1 + R2C2+ R1C2)^2 - 4*(R1C1*R2C2)

s1<- (-(R1C1 + R2C2+ R1C2)+sqrt(delta))/(2*(R1C1*R2C2))

s2<- (-(R1C1 + R2C2+ R1C2)-sqrt(delta))/(2*(R1C1*R2C2))

FT_denom<- function(s){
  denom<-R1C1*R2C2*(s^2) + (R1C1 + R2C2+ R1C2)*s +1
  return(denom)
}
FT_denom(0)
```


Mas primeiro, devemos fazer o isolamento
```{r}
s<- seq(from=-15,to=0,by=0.5)

FT_denom(s)

ggplot()+ geom_line(aes(x= s, y = FT_denom(s)))

tabela<-cbind(s,FT_denom(s),sign(FT_denom(s)))

print(tabela)

muda_sinal_anterior<-c(FALSE)

for (i in 2:nrow(tabela)) {
muda_sinal_anterior[i]  <-!(sign(tabela[i-1,2]) == sign(tabela[i,2]))
 
}
tabela2<- cbind(tabela, "mudou o sinal?" = muda_sinal_anterior)

print(tabela2)

intervalos<-list(0)
for (i in 2:nrow(tabela2)) {
  if (tabela2[i,4]==1){
    if (tabela2[i-1,3] == 1) {
  intervalos[[i-1]] <- cbind(tabela2[i-1,1],tabela2[i,1])
    }
    else if (tabela2[i-1,3] == -1){
      intervalos[[i-1]] <- cbind(tabela2[i,1],tabela2[i-1,1])
    }
  }
  else{
    intervalos[[i-1]] <- NA
  
  }
}


intervalos<-intervalos[!is.na(intervalos)]
print(intervalos)

```

# Usando a técnica de Bissecção

```{r}
m1<-function(a,b){
  x0<- (a+b)/2
  return(x0)
}
erro<- c(0.01)
raizes<-c(0)
j<-1
k<-1
#para primeiro intervalo
  a<- intervalos[[j]][[1]]
b<- intervalos[[j]][[2]]
tbl1<-matrix(nrow = 1,ncol = 3)
x_barra<-m1(a,b)
f_x_barra <- FT_denom(x_barra) #iniciar
tbl1<-cbind(k,x_barra,f_x_barra)
while (abs(f_x_barra)> erro) {
 if (sign(f_x_barra) == -1){
  b<-x_barra
      x_barra<-m1(a,b)
      f_x_barra <- FT_denom(x_barra)
      k<- k + 1
      tbl1<-rbind(tbl1,cbind(k,x_barra,f_x_barra))
 } else if (sign(f_x_barra) == 1){
  a<-x_barra
  x_barra<-m1(a,b)
      f_x_barra <- FT_denom(x_barra)
     k<- k + 1  
     tbl1<-rbind(tbl1,cbind(k,x_barra,f_x_barra))
 }
  
  print(k)
raizes[j]<-x_barra
}

#Para segundo intervalo
j<-2
k<-1

  a<- intervalos[[j]][[1]]
b<- intervalos[[j]][[2]]
tbl1_1<-matrix(nrow = 1,ncol = 3)
x_barra<-m1(a,b)
f_x_barra <- FT_denom(x_barra) #iniciar
tbl1_1<-cbind(k,x_barra,f_x_barra)
while (abs(f_x_barra)> erro) {
 if (sign(f_x_barra) == -1){
  b<-x_barra
      x_barra<-m1(a,b)
      f_x_barra <- FT_denom(x_barra)
      k<- k + 1
     tbl1_<-rbind(tbl1_1,cbind(k,x_barra,f_x_barra))
     
 } else if (sign(f_x_barra) == 1){
  a<-x_barra
  x_barra<-m1(a,b)
      f_x_barra <- FT_denom(x_barra)
      k<- k + 1
    tbl1_1<-rbind(tbl1_1,cbind(k,x_barra,f_x_barra))
   
 }
  
 
raizes[j]<-x_barra
print(raizes)
}

```
# Método da Posição Falsa

````{r}
m2<- function(a,b){
  x0<- (a*FT_denom(a) -b*FT_denom(b))/(FT_denom(a)-FT_denom(b))
  return(x0)
}
erro<- c(0.01)
raizes2<-c(0)
j<-1
k<-0

#Primeiro intervalo

tbl2_1<-matrix(nrow=1,ncol=3)
  a<- intervalos[[j]][[1]]
b<- intervalos[[j]][[2]]
x_barra<-m2(a,b)
f_x_barra <- FT_denom(x_barra) #iniciar
tbl2_1<-cbind(k,x_barra,f_x_barra)

while ( abs(b-a) & abs(FT_denom(a)) & abs(FT_denom(b)) & abs(FT_denom(x_barra)) > erro) {
 if (sign(f_x_barra) == -1){
      b<-x_barra
      a
      b
      x_barra<-m2(a,b)
      x_barra
      f_x_barra <- FT_denom(x_barra)
        k<- k + 1
    tbl2_1<-rbind(tbl2_1,cbind(k,x_barra,f_x_barra))
 } else if (sign(f_x_barra) == 1){
      a<-x_barra
      a
      b
      x_barra<-m2(a,b)
      x_barra
      f_x_barra <- FT_denom(x_barra)
      f_x_barra
       k<- k + 1
    tbl2_1<-rbind(tbl2_1,cbind(k,x_barra,f_x_barra))
     
 }
  
raizes2[j]<-x_barra
}


#Segundo Intervalo
j<-2
k<-0



tbl2_2<-matrix(nrow=1,ncol=3)
  a<- intervalos[[j]][[1]]
b<- intervalos[[j]][[2]]
x_barra<-m2(a,b)
f_x_barra <- FT_denom(x_barra) #iniciar
tbl2_2<-cbind(k,x_barra,f_x_barra)

while ( abs(b-a) & abs(FT_denom(a)) & abs(FT_denom(b)) & abs(FT_denom(x_barra)) > erro) {
 if (sign(f_x_barra) == -1){
      b<-x_barra
      a
      b
      x_barra<-m2(a,b)
      x_barra
      f_x_barra <- FT_denom(x_barra)
        k<- k + 1
    tbl2_2<-rbind(tbl2_2,cbind(k,x_barra,f_x_barra))
 } else if (sign(f_x_barra) == 1){
      a<-x_barra
      a
      b
      x_barra<-m2(a,b)
      x_barra
      f_x_barra <- FT_denom(x_barra)
      f_x_barra
       k<- k + 1
    tbl2_2<-rbind(tbl2_2,cbind(k,x_barra,f_x_barra))
     
 }
  
raizes2[j]<-x_barra
}


```

# Método de ponto Fixo

Necessário determinar uma função phi(x), isolando o x. Para o nosso caso, devemos isolar o s da FT_denom, R1C1*R2C2*(s^2) + (R1C1 + R2C2+ R1C2)*s +1. Temos a opção de isolar da primeira parcela que está elevado ao quadrado, ou da segunda parcela. Faremos ambos.

```{r}
phi1 <- function(s){ ##isolando s da segunda parcela
  x0<- (R1C1*R2C2*(s^2)+1)/(R1C1 + R2C2+ R1C2)*-1
  return(x0)
}

phi2 <- function(s){
  x0<- (sqrt(((R1C1 + R2C2+ R1C2)*s +1)/(R1C1*R2C2)))*-1
  return(x0)
}
phi3 <- function(s){ ##isolando s da segunda parcela
  x0<- (-1)/(R1C1*R2C2*(s)+(R1C1 + R2C2+ R1C2))
  return(x0)
}

phi4 <- function(s){ ##isolando s da segunda parcela
  x0<- (-1*(R1C1 + R2C2+ R1C2)*s -1)/(R1C1*R2C2*(s))
  return(x0)
}


intervalos
a<- intervalos[[1]][[1]]
b<-intervalos[[1]][[2]]
x0<- (a+b)/2

xx<- c(0)
for (i in 1:3) {
  t<- phi1(x0)
  xx[i]<-x0
  x0<-t
}

x0<- (a+b)/2
xx2<- c(0)
for (i in 1:3) {
  t<- phi2(x0)
  xx2[i]<-x0
  x0<-t
}
xx2

x0<- (a+b)/2
xx3<- c(0)
for (i in 1:3) {
  t<- phi3(x0)
  xx3[i]<-x0
  x0<-t
}
xx3

x0<- (a+b)/2
xx4<- c(0)
for (i in 1:3) {
  t<- phi4(x0)
  xx4[i]<-x0
  x0<-t
}
xx4
```
A função phi2 tem um limite de intervalo dentro do plano real devido a raiz. Por isso, usaremos phi1 e phi4.

```{r}
raizes3_1<- c(0)
#para primeiro intervalo
j<-1

tbl3_1<-matrix(nrow=1,ncol=3)
  a<- intervalos[[j]][[1]]
  b<- intervalos[[j]][[2]]
  x_barra<- (a+b)/2
  x1<- 1
  
  f_x_barra <- FT_denom(x_barra) #iniciar
  k<- 0
 tbl3_1<-cbind(k,x_barra,f_x_barra)
  
  while (abs(f_x_barra)>erro & abs(x1)>erro) {
        t<- phi1(x_barra)
        x1<- (x_barra-t)
        x_barra<-t
        print(x_barra)
        f_x_barra <- FT_denom(x_barra)
        k<- k+1
        tbl3_1<-rbind(tbl3_1,cbind(k,x_barra,f_x_barra))
        raizes3_1[j]<-t
  }
  

print(raizes3)
ggplot()+geom_line(aes(x = x, y = phi1(x))) + geom_line(aes(x = x, y =x))


```
Para o primeiro intervalo ( -13 -12.5), a função phi1 converge para a segunda raiz (-0.9787618) e não para a raiz dentro deste intervalo. Vamos tentar o segundo intervalo.

```{r}
raizes3_2<- c(0)
#para segundp intervalo
j<-2

tbl3_2<-matrix(nrow=1,ncol=3)
  a<- intervalos[[j]][[1]]
  b<- intervalos[[j]][[2]]
  x_barra<- (a+b)/2
  x1<- 1
  
  f_x_barra <- FT_denom(x_barra) #iniciar
  k<- 0
 tbl3_2<-cbind(k,x_barra,f_x_barra)
  
  while (abs(f_x_barra)>erro & abs(x1)>erro) {
        t<- phi1(x_barra)
        x1<- (x_barra-t)
        x_barra<-t
        print(x_barra)
        f_x_barra <- FT_denom(x_barra)
        k<- k+1
        tbl3_2<-rbind(tbl3_2,cbind(k,x_barra,f_x_barra))
        raizes3_2[j]<-t
  }
  



```

Por algum motivo, Phi1 não funciona para o intervalo -13 a -12.5. Parece ter apenas um ponto de convergência. Vamos testar phi4 para ambos intervalos.
```{r}
ggplot()+geom_line(aes(x = s, y = phi4(s))) + geom_line(aes(x = s, y =s))

raizes3_3<- c(0)
#para primeiro intervalo
j<-1

tbl3_3<-matrix(nrow=1,ncol=3)
  a<- intervalos[[j]][[1]]
  b<- intervalos[[j]][[2]]
  x_barra<- (a+b)/2
  x1<- 1
  
  f_x_barra <- FT_denom(x_barra) #iniciar
  k<- 0
 tbl3_3<-cbind(k,x_barra,f_x_barra)
  
  while (abs(f_x_barra)>erro & abs(x1)>erro) {
        t<- phi4(x_barra)
        x1<- (x_barra-t)
        x_barra<-t
        print(x_barra)
        f_x_barra <- FT_denom(x_barra)
        k<- k+1
        tbl3_3<-rbind(tbl3_3,cbind(k,x_barra,f_x_barra))
        raizes3_3[j]<-t
  }
  

print(tbl3_3)



```
```{r}
#para segundo intervalo
j<-2

tbl3_4<-matrix(nrow=1,ncol=3)
  a<- intervalos[[j]][[1]]
  b<- intervalos[[j]][[2]]
  x_barra<- (a+b)/2
  x1<- 1
  
  f_x_barra <- FT_denom(x_barra) #iniciar
  k<- 0
 tbl3_4<-cbind(k,x_barra,f_x_barra)
  
  while (abs(f_x_barra)>erro & abs(x1)>erro) {
        t<- phi4(x_barra)
        x1<- (x_barra-t)
        x_barra<-t
        print(x_barra)
        f_x_barra <- FT_denom(x_barra)
        k<- k+1
        tbl3_4<-rbind(tbl3_4,cbind(k,x_barra,f_x_barra))
        raizes3_3[j]<-t
  }
  





```
A função phi4 também parece convergir apenas para uma das raízes.


## Método Newton Raphson

O método tenta escolher uma função phi de iteração cujo phi'(raiz)=0

As condições de convergência são:
* f(x), f'(x) e f''(x) são contínuas em I;
* f'(x) diferente de zero;
* x0 está próximo da raiz.

Precisaremos da derivada da função de i


```{r}
#Derivada da Função de Transferência

FT_linha<- function(s){
  denom<-  2*R1C1*R2C2*(s) + (R1C1 + R2C2+ R1C2)
  return(denom)
}


m4<- function(x_barra){
  x0<- x_barra - FT_denom(x_barra)/FT_linha(x_barra)
  return(x0)
}

#para primeiro intervalo

erro<- c(0.01)
raizes4_1<-c(0)



j<-1
  k<- 0
  
tbl4_1<-matrix(nrow=1,ncol=3)
  a<- intervalos[[j]][[1]]
  b<- intervalos[[j]][[2]]
  x_barra<- (a+b)/2
  x1<- 10000000
  
  
  f_x_barra <- FT_denom(x_barra) #iniciar

 tbl4_1<-cbind(k,x_barra,f_x_barra)
  
  while (abs(f_x_barra)>erro & abs(x1)>erro) {
        t<- m4(x_barra)
        x1<- (x_barra-t)
        x_barra<-t
        print(x_barra)
        f_x_barra <- FT_denom(x_barra)
        k<- k+1
        tbl4_1<-rbind(tbl4_1,cbind(k,x_barra,f_x_barra))
        raizes4_1[j]<-t
  }
  

#para segundo intervalo

erro<- c(0.01)
raizes4_2<-c(0)



j<-2
  k<- 0
  
tbl4_2<-matrix(nrow=1,ncol=3)
  a<- intervalos[[j]][[1]]
  b<- intervalos[[j]][[2]]
  x_barra<- (a+b)/2
  x1<- 10000000
  
  
  f_x_barra <- FT_denom(x_barra) #iniciar

 tbl4_2<-cbind(k,x_barra,f_x_barra)
  
  while (abs(f_x_barra)>erro & abs(x1)>erro) {
        t<- m4(x_barra)
        x1<- (x_barra-t)
        x_barra<-t
        print(x_barra)
        f_x_barra <- FT_denom(x_barra)
        k<- k+1
        tbl4_2<-rbind(tbl4_2,cbind(k,x_barra,f_x_barra))
        raizes4_2[j]<-t
  }
  
```

## Método da Secante

Há situaçoes em que a derivada da f(x) possa ser um problema.

Inicia com dois chutes iniciais.


```{r}
m5<- function(xk0,xk01){
  x0<- FT_denom(xk1)*(xk1-xk0)/(FT_denom(xk1) - FT_denom(xk0))
  return(x0)
}


#para primeiro intervalo

erro<- c(0.01)
raizes4_1<-c(0)



j<-1
  
  
tbl5_1<-matrix(nrow=1,ncol=3)
  a<- intervalos[[j]][[1]]
  b<- intervalos[[j]][[2]]
  xk0<-a
  xk1<-b

  #x_barra<- (a+b)/2
  x1<- 10000000
  
  fxk0<- FT_denom(xk0)
  fxk1<- FT_denom(xk1)
  

 tbl5_1<-cbind(0,xk0,fxk0)
 tbl5_1<-rbind(tbl5_1,cbind(1,xk1,fxk1))
  k<- 2
  x_barra<- 999 #apenas iniciar
  f_x_barra <- FT_denom(x_barra) #iniciar
  while (abs(f_x_barra)>erro & abs(x1)>erro) {
        x_barra<- xk1
        t<- m5(xk0,xk1)
        x1<- (x_barra-t)
        x_barra<-t
        print(x_barra)
        f_x_barra <- FT_denom(x_barra)
        k<- k+1
        tbl4_1<-rbind(tbl4_1,cbind(k,x_barra,f_x_barra))
        raizes4_1[j]<-t
  }
  

#para segundo intervalo

erro<- c(0.01)
raizes4_2<-c(0)



j<-2
  k<- 0
  
tbl4_2<-matrix(nrow=1,ncol=3)
  a<- intervalos[[j]][[1]]
  b<- intervalos[[j]][[2]]
  x_barra<- (a+b)/2
  x1<- 10000000
  
  
  f_x_barra <- FT_denom(x_barra) #iniciar

 tbl4_2<-cbind(k,x_barra,f_x_barra)
  
  while (abs(f_x_barra)>erro & abs(x1)>erro) {
        t<- m4(x_barra)
        x1<- (x_barra-t)
        x_barra<-t
        print(x_barra)
        f_x_barra <- FT_denom(x_barra)
        k<- k+1
        tbl4_2<-rbind(tbl4_2,cbind(k,x_barra,f_x_barra))
        raizes4_2[j]<-t
  }
  
```


```

